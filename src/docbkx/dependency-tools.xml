<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book[
<!ENTITY % myents SYSTEM "./shared.ent" >
%myents;
]>
<book status="draft" xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en">
  <info>
    <title><emphasis>&productName;</emphasis> User Guide</title>
    <revhistory>
      <revision>
        <revnumber>0.1</revnumber>
        <date>2014-08-12</date>
        <author>
          <personname>
            <firstname>Julien</firstname>
            <surname>TOUS</surname>
          </personname>
        </author>
        <revremark>First revision of <emphasis>&productName;</emphasis> User Guide</revremark>
      </revision>
      <revision>
        <revnumber>0.2</revnumber>
        <date>2014-09-26</date>
        <author>
          <personname>
            <firstname>Fran√ßois</firstname>
            <surname>DELOYE</surname>
          </personname>
        </author>
        <revremark>Document rework to export parts in MindC and plugins User Guide</revremark>
      </revision>
    </revhistory>
  </info>
  
  <chapter>
    <title>Introduction</title>
    
    <section>
      <title>Aim of this document</title>
      
      <para>This document introduces the <emphasis>&productName;</emphasis> provided with the mind
        compiler and demonstrates their usage using examples.</para>
      <para>The new commands: <command>object-dependencies</command> and
          <command>mind-violation</command> are targeted to identify and display the dependencies
        between object files generated by a compilation.</para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="sections/dependency-tools_aim.xml"/>
  </chapter>
  <chapter>
    <title>The <command>object-dependencies</command> tool</title>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
      href="sections/object-dependencies_cmd.xml"/>
    <section>
      <title>Analysis of an example</title>
      
      <para>The <filename>object-dependencies</filename> example is a standard C project (that does
        nothing interesting) constituted of 6 C modules : <filename>a.c</filename>,
          <filename>b.c</filename>, <filename>c.c</filename>, <filename>d.c</filename>,
          <filename>e.c</filename> and <filename>main.c</filename>. Each of these modules but
          <filename>main.c</filename> exports some symbols using standard C preprocessor mechanism
        through header files <filename>a.h</filename>, <filename>b.h</filename>,
          <filename>c.h</filename>, <filename>d.h</filename>, <filename>e.h</filename>. The symbols
        in each module have been smartly named : <code>a_bas</code>, <code>a_data</code> and
          <code>a_text</code> originate from the <filename>a.c</filename> module.</para>
      
      <para>After building the application using the provided Makefile (using <command>make
          all</command> command), 6 object files should be found (<filename>a.o</filename>,
          <filename>b.o</filename>, <filename>c.o</filename>, <filename>d.o</filename>,
          <filename>e.o</filename> and <filename>main.o</filename>) plus an executable file
          (<filename>legacyC</filename>).</para>
      
      <section>
        <title>Dependency graph</title>
        <para>To create a dependency graph from the object files, run the command :</para>
        <programlisting> $ object-dependencies --graph=abcde.gv src/a.o src/b.o src/c.o src/d.o src/e.o src/main.o</programlisting>
        <para>On a larger program, using a search tool can be useful, for example :</para>
        <programlisting> $ object-dependencies --graph=abcde.gv src/*.o</programlisting>
        <para> or </para>
        <programlisting> $ object-dependencies --graph=abcde.gv `find src -name *.o`</programlisting>
        <para>The output is the graph file <filename>abcde.gv</filename>.</para>
        <para>This graph can be visualized using one layout program, such as <command>dot</command> from
          the <code>Graphviz</code> package. </para>
        <para>The following command transforms the <code>.gv</code> file into a <code>.svg</code>
          :</para>
        <programlisting> $ dot -Tsvg abcde.gv &gt; abcde.svg</programlisting>
        <example>
          <title>Dependency graph</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata align="center" fileref="images/abcde.svg"/>
            </imageobject>
          </mediaobject>
        </example>
        <para>The above graph tells us that : <itemizedlist>
          <listitem>
            <para><filename>main.o</filename> uses the symbol <code>a_text</code> that is defined
              in the <filename>a.o</filename> module.</para>
          </listitem>
          <listitem>
            <para><filename>a.o</filename> uses the symbol <code>b_bss</code> and
              <code>b_data</code> from <filename>b.o</filename> and <code>c_text</code> and
              <code>c_data</code> from <filename>c.o</filename>.</para>
          </listitem>
          <listitem>
            <para><filename>d.o</filename> uses the symbol <code>e_data</code> from
              <filename>e.o</filename> whereas <code>e.o</code> uses the symbol
              <code>d_text</code> from <filename>d.o</filename>.</para>
          </listitem>
          <listitem>
            <para>...</para>
          </listitem>
        </itemizedlist></para>
        <para>By default, the graph details all the symbols used from each module. It is possible to
          extract a simplified view from this graph using the script <command>simplifyDot</command>
          distributed with the Mind tool-chain.</para>
        <para>The following command will create a simplified graph :</para>
        <programlisting> $ simplifyDot abcde.gv &gt; abcdeSimple.gv</programlisting>
        <example>
          <title>Simplified dependency graph</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata align="center" fileref="images/abcdeSimple.svg"/>
            </imageobject>
          </mediaobject>
        </example>
        <para>The simplified view shows only the dependencies between modules, not their names and
          the arrow width represents the number of symbols used.</para>
      </section>
      
      <section>
        <title>Dependency Structure Matrix</title>
        <para>To create a dependency structure matrix from the object files, run the command :</para>
        <programlisting> $ object-dependencies --dsm=abcde.csv src/a.o src/b.o src/c.o src/d.o src/e.o src/main.o</programlisting>
        <para>The output is the file <filename>abcde.csv</filename>.</para>
        <para>The Dependency Structure Matrix (DSM) included in the file can be visualized using
          <application>Excel</application> for example:</para><table frame="all">
            <title>Dependency structure matrix</title>
            <tgroup align="left" cols="8" colsep="1" rowsep="1">
              <colspec colname=""/>
              <colspec colname="Hierachy ID"/>
              <colspec colname="1"/>
              <colspec colname="2"/>
              <colspec colname="3"/>
              <colspec colname="4"/>
              <colspec colname="5"/>
              <colspec colname="6"/>
              <thead>
                <row>
                  <entry/>
                  <entry>Hierarchy ID</entry>
                  <entry>1</entry>
                  <entry>2</entry>
                  <entry>3</entry>
                  <entry>4</entry>
                  <entry>5</entry>
                  <entry>6</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry><filename>main.o</filename></entry>
                  <entry>1</entry>
                  <entry/>
                  <entry/>
                  <entry>1</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry><filename>d.o</filename></entry>
                  <entry>2</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                  <entry/>
                  <entry>1</entry>
                  <entry/>
                </row>
                <row>
                  <entry><filename>a.o</filename></entry>
                  <entry>3</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                  <entry>1</entry>
                  <entry/>
                  <entry>1</entry>
                </row>
                <row>
                  <entry><filename>b.o</filename></entry>
                  <entry>4</entry>
                  <entry/>
                  <entry>1</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry><filename>e.o</filename></entry>
                  <entry>5</entry>
                  <entry/>
                  <entry>1</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry><filename>c.o</filename></entry>
                  <entry>6</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                  <entry/>
                  <entry>1</entry>
                  <entry/>
                </row>
              </tbody>
            </tgroup>
          </table>
        <para>The information in the DSM is equivalent to the one provided in the simple graph. </para>
        <para>The two first columns relate the modules name with a numeral <code>hierarchy
          ID</code>.</para>
        <para>The rows from the second to the last represent the dependencies between modules. </para><para> A '<code>1</code>' at the crossing of <code>hierarchy IDs</code> indicates a dependency
          between modules.</para>
        <para>The above table tells :
          <itemizedlist>
            <listitem>
              <para>From the 2<superscript>nd</superscript> row, that <filename>main.o</filename> uses the
                module with <code>hierarchy ID</code> 3, that is <filename>a.o</filename>.</para>
            </listitem>
            <listitem>
              <para>From the 7<superscript>th</superscript>  column, that the module with
                <code>hierarchy ID</code> 5 (<filename>e.o</filename>) is used by the modules
                <filename>d.o</filename> and <filename>c.o</filename></para>
            </listitem>
            <listitem>
              <para>...</para>
            </listitem>
          </itemizedlist></para><para> The <filename>abcde.csv</filename> file can also be imported within
            <application>CAM</application> that provides algorithm for clustering highly dependent
          modules and triangulating the matrix. <example>
            <title>Import of the CSV file within <application>CAM</application></title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata align="center" fileref="images/CamAbcdeImport.png"/>
              </imageobject>
            </mediaobject>
          </example>
          <example>
            <title>Clustering and triangulating with <application>CAM</application></title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata align="center" fileref="images/CamAbcdeClustered.png"/>
              </imageobject>
            </mediaobject>
          </example> Those tools are not targeted to replace architecture document, but they provide
          great help to analyse large pieces of code.</para></section>
    </section>
  </chapter>
  
  <chapter>
    <title>The <command>mind-violation</command> tool</title>
    
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="sections/mind-violation_cmd.xml"/>
    
    <section>
      <title>Analysis of an example</title>
      <section>
        <title>Example application overview</title>
        <para>The <filename>mind-violation</filename> example is a Mind application.</para>
        <para>In a <code>GalaxyFarFarAway</code> the <code>DeathStar</code> has taken the
          <code>MilleniumFalcon</code> prisoner. </para>
        <para>Both spacecrafts are made of a <code>SpacecraftEngine</code> that monitors the
          incoming and outgoing of its passengers. <code>DarthVader</code> is passenger of the
          <code>DeathStar</code>. </para>
        <para><code>Luc</code>, <code>Leia</code> and <code>Han</code> are passengers of the
          <code>MilleniumFalcon</code>. </para>
        <para>All characters can react to one another when they meet. </para>
        <para>The <code>Pitch</code> component controls the evolution of the spacecrafts and
          characters.</para>
        <example>
          <title>Application overview</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata align="center" fileref="images/StarWarOverview.svg"
                scale="50"/>
            </imageobject>
          </mediaobject>
        </example>
        <para>To build the application, run the <command>make compile</command> command. Running the
          application prints to the screen dialogs between the characters :</para>
        <programlisting> $ ./target/Default/binaries/StarWar

DarthVader, the commander of the DeathStar welcomes his prisoners from the MilleniumFalcon.

Han Solo is getting out the MilleniumFalcon.
DarthVader : Go away from me Han Solo !
Han Solo : Hehe...

Luc is getting out the MilleniumFalcon.
DarthVader : I'm your father Luc !
Luc : The bright side of the force will rise again DarthVader !

Leia is getting out the MilleniumFalcon.
DarthVader : Go away from me Leia !
Leia : DarthVader !

But they all escape !

Leia is getting in the MilleniumFalcon.
Luc is getting in the MilleniumFalcon.
Han Solo is getting in the MilleniumFalcon.

The MilleniumFalcon is taking of !

And congratulate each other.

Luc : The bright side of the force will rise again Han Solo !
Han Solo : Hehe...

Leia : I love you Han Solo !
Han Solo : I love you Leia !

Leia : Luc !
Luc : The bright side of the force will rise again Leia !</programlisting>
      </section>
      <section>
        <title>Examining the hidden dependencies</title>
        <para>To track the hidden dependencies between those components, run the command :</para>
        <programlisting> $ mind-violation target/Default/binaries/</programlisting>
        <para>Three files
          (<code>HiddenDeps.gv</code>, <code>HiddenDeps.csv</code> and
          <code>HiddenDeps.txt</code>) are created in the directory
          <code>target/Default</code></para>
        <orderedlist>
          <listitem>
            <para><filename>HiddenDeps.gv</filename> can be visualized with a layout program, such as
              <command>dot</command> from the <code>Graphviz</code> package, as explained in the
              previous chapter</para>
            <example>
              <title>Graph of hidden dependencies in the application.</title>
              <mediaobject>
                <imageobject role="fo">
                  <imagedata align="center"
                    fileref="images/StarWarHiddenDeps.dot.svg" scale="50"/>
                </imageobject>
              </mediaobject>
            </example>
            <para>The previous graph tells that :</para>
            <itemizedlist>
              <listitem>
                <para>The component <code>DarthVader</code> depends on the symbol <code>LucName</code>
                  that is defined in the component <code>Luc</code>.</para>
              </listitem>
              <listitem>
                <para>The component <code>Leia</code> depends on the symbol
                  <code>Han</code>, whereas the component <code>Han</code> depends
                  on the symbol <code>Leia</code>.</para>
              </listitem>
            </itemizedlist>
            <para>Note: In the architecture diagram, dependencies are expressed between <emphasis
              role="bold">instances</emphasis>, whereas hidden dependencies are expressed between
              <emphasis role="bold">definitions</emphasis>.</para>
            <para>Looking at the ADLs gives the relation between instances and types that can relate
              both diagrams.</para>
            <programlisting language="adl">...
contains starwars.empire.character.DarthVader as commander;
...
contains starwars.alliance.character.Han as pilote;
contains starwars.alliance.character.Luc as jedi;
contains starwars.alliance.character.Leia as princess;	 
...</programlisting>
          </listitem>
          <listitem>
            <para>
              The <filename>HiddenDeps.csv</filename> file can be visualized using
              <application>Excel</application> or <application>CAM</application>.</para>
            <example>
              <title>Dependency structure matrix of hidden dependencies in the
                <application>CAM</application> application</title>
              <mediaobject>
                <imageobject role="fo">
                  <imagedata align="center"
                    fileref="images/StarWarHiddenDeps.csv.png" scale="50"/>
                </imageobject>
              </mediaobject>
            </example>
          </listitem>
          <listitem>
            <para>
              The <filename>HiddenDeps.txt</filename> file is a plain text file that
              describes the hidden dependencies.</para>
            <example>
              <title>Extract  of the textual description of the hidden dependencies</title>
              <programlisting>...   
DarthVader {
Defined symbols :
Undefined symbols :
LucName                resolved by Luc
printf                 unresolved 
}

Han {
Defined symbols :
HanName                data
Undefined symbols :
LeiaName               resolved by Leia
printf                 unresolved 
}

Leia {
Defined symbols :
LeiaName               data
Undefined symbols :
HanName                resolved by Han
printf                 unresolved 
}

Luc {
Defined symbols :
LucName                data
Undefined symbols :
printf                 unresolved 
}

SpacecraftEngine {
Defined symbols :
Undefined symbols :
printf                 unresolved 
}

Pitch {
Defined symbols :
Undefined symbols :
printf                 unresolved 
putchar                unresolved 
puts                   unresolved 
}
...</programlisting>
            </example>
            <para>In the textual representation, component names are followed (between braces) by a
              summary of dependencies from and to other components. </para>
            <para>For example : component <code>Leia</code> :</para>
            <itemizedlist>
              <listitem>
                <para>Exports the symbol <code>LeiaName</code> that belongs to the
                  <code>data</code> section.</para>
              </listitem>
              <listitem>
                <para>Uses the symbol <code>HanName</code> that is defined in the
                  <code>Han</code> component.</para>
              </listitem>
              <listitem>
                <para>Uses the symbol <code>printf</code> that is not defined in any of the
                  components. <code>printf</code> is defined by <code>libc</code> and is not part of
                  a component here.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </orderedlist>
      </section>
      
      <section>
        <title>Treating the hidden dependencies</title>
        <note>
          <para>Hidden dependencies must be used with care because, they may lead to unwanted
          behaviours, here are few examples :</para>
          <para>
            <itemizedlist>
              <listitem>
                <para>In case of multi-instanciation of a component A that exposes a data variable,
                  the exposed data is not duplicated but shared between all the instances of the
                  component A (similar to a class variable in Java).</para>
                <para>To avoid this kind of issue, a recommendation is to declare components with
                  data exposed as singleton (with the <code>@Singleton</code> annotation).</para>
              </listitem>
              <listitem>
                <para>If a component is inherited from a component A that exposes a data variable,
                  since the source code of the ancestor component A may be duplicated in the
                  inherited component, the build would fail since the exposed data variable is
                  duplicated.</para>
                <para>lecTo avoid this kind of issue, a recommendation is to define the data as
                    <code>static</code> to reduce the scope of the data.</para>
              </listitem>
            </itemizedlist>
          </para>
        </note>
        
        <para> When mixing standard <code>C</code> code with <code>Mind</code> components, symbols
          have to be exported and imported from components.</para>
        <para>However to be fully reusable, a component must NOT rely on such features, so an
          application made of "pure" Mind components will lead to empty <code>HiddenDeps.gv</code>
          graph and <code>HiddenDeps.csv</code> matrix. </para>
        <para> In many cases partial re-usability is enough : for example relying on the
            <code>libc</code> can be acceptable. When developing components, such a design rule must
          be clearly documented. </para>
        <para> By looking at the code of <code>DarthVader</code>, let us focus on the dependency to
          <code>Luc</code>, </para>
        <example>
          <title>DarthVader dependency to Luc</title>
          <programlisting language="c">...   
#include "starwars/alliance/character/Luc.h"

string* DarthVaderSonName = &amp;LucName;
...
if (interlocutorName == *DarthVaderSonName) {
...</programlisting>
        </example>
        <para>Here are some possible solutions to treat the hidden dependency mentioned above
          :</para> 
        <orderedlist>
          <listitem>
            <para>Do nothing but document the dependency in the
              <code>DarthVader</code> ADL :</para>
            <programlisting language="c">/**
* This component implicitly depends on an external symbol :
*     string LucName;
* that is provided by the component starwars.alliance.character.Luc
* Thus this component cannot be instantiated "as is", 
* if Luc component is not instantiated in the Application.
*/</programlisting>
            <para>This solution involves almost no workload, no overhead to
              the program, the application is still difficult to understand.
              Such specific design rules are hard to track.</para>
          </listitem>
          <listitem>
            <para>Modify the components to use comparison of strings instead
              of comparison of string pointers. <code>DarthVader</code> code
              becomes :</para>
            <programlisting language="c">...
// Defines LUCNAME as "Luc" !
#include "starwars/alliance/character/Luc.h" 

string DarthVaderSonName = LUCNAME;
...
if (!strcmp(interlocutorName,DarthVaderSonName)) {
...</programlisting>
            <para>This solution transforms the symbol dependency into a build dependency (that fits
              well the reality). <code>DarthVader</code> can be used in an application where
              <code>Luc</code> is not instantiated. This costs an extra string
              <code>LUCNAME</code> and a call to <code>strcmp</code>.</para>
          </listitem>
          <listitem>
            <para>Express the dependency from <code>DarthVader</code> to <code>Luc</code> with an
              interface and a binding :</para>
            <programlisting language="adl">primitive starwars.empire.character.DarthVader {
requires starwars.Character as son;
...</programlisting>
            <programlisting language="cpl">...
if (interlocutorName == CALL(son,getName()) {
...</programlisting>
            <para>Although this solution removes the hidden dependency, it introduces lots of
              complexity in the architecture. Especially if you also treat the fact that
                <code>Han</code> and <code>Leia</code> are lovers (the other hidden dependencies).
              If you want to enhance the components to take into account that <code>Leia</code> is
              also daughter of <code>DarthVader</code>, <code>Luc</code> is brother of
                <code>Leia</code>..., soon the architecture will become hard to understand. But in
              many other cases, this solution is the way to go.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </chapter>
</book>
